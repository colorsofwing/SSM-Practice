<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="lyons.dao.GoodsDao"><!-- 面向接口编程。与此类关联，作为空间名 -->

    <!-- 数据库中Goods表与javaBean的变量名对应关系 -->
    <!-- type:对应java对应表的实体类名  id:别名（可以与select等的id重名）-->
    <resultMap type="lyons.entity.Goods" id="GoodsResult">

        <!-- (id:数据库表主键 result：数据库表普通的列)  property：javaBean中字段对应的变量名字-->
        <!-- column：与查询的列名相同并非数据库里面的列名。比如select id a from 表名 查询的列名用了别名a那么就得对应的修改column="a"-->
        <id column="commodity_number" jdbcType="INTEGER" property="commodity_number"/>
        <result column="commodity_name" jdbcType="VARCHAR" property="commodity_name"/>
        <result column="commodity_made" jdbcType="VARCHAR" property="commodity_made"/>
        <result column="commodity_price" jdbcType="DOUBLE" property="commodity_price"/>
        <result column="commodity_balance" jdbcType="INTEGER" property="commodity_balance"/>
        <result column="commodity_pic" jdbcType="VARCHAR" property="commodity_pic"/>
        <result column="commodity_id" jdbcType="INTEGER" property="commodity_id"/>

        <!-- 作为主表时使用该标签。 collection：代表对应一个集合  resultMap：引用Classify.XML的映射关系 配置这个的原因是引用子表查询了 -->
        <!--<collection property="goodsClassifyList" resultMap="lyons.dao.GoodsClassifyDao.ClassifyResult" />&lt;!&ndash; 一对多 空间名.id &ndash;&gt;-->

    </resultMap>



    <!-- 定义常量 。写出查询的列代替*效率高-->
    <sql id="columns">SELECT commodity_number,commodity_name,commodity_made,commodity_price,commodity_balance,commodity_pic,commodity_id
        FROM commodity
    </sql>

    <!-- 解释： id：为该sql语句起一个名字（用于SqlFaction调用该sql语句）resultMap：对应上述resultMap的id -->
    <!-- select查出来的信息放到<resultMap>对应的property变量名中 -->
    <select id="goodsAllList"  resultMap="GoodsResult">
        <include refid="columns"/> <!-- 引用<sql>中定义的常量 -->
    </select>

</mapper>
